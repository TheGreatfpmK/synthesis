dtmc

const int N = 30;
const int M = N;
const int NDIV = 15;
const int MDIV = NDIV;

//
// 2-FSC
//
// holes
hole int M_0_0_0_0 in {0,1};
hole int M_1_0_0_0 in {0,1};

hole int M_0_1_0_0 in {0,1};
hole int M_1_1_0_0 in {0,1};


hole int M_0_0_1_0 in {0,1};
hole int M_1_0_1_0 in {0,1};

hole int M_0_1_1_0 in {0,1};
hole int M_1_1_1_0 in {0,1};



hole int P_0_0_0_0 in {1,2,3,4};
hole int P_1_0_0_0 in {1,2,3,4};

hole int P_0_1_0_0 in {1,2,3,4};
hole int P_1_1_0_0 in {1,2,3,4};


hole int P_0_0_1_0 in {1,2,3,4};
hole int P_1_0_1_0 in {1,2,3,4};

hole int P_0_1_1_0 in {1,2,3,4};
hole int P_1_1_1_0 in {1,2,3,4};



formula xobs = floor((x-1)/NDIV); // 0..1
formula yobs = floor((y-1)/MDIV); // 0..1
formula end = x=N & y=M; // bool

formula slip = 1/2 + 1/ (100 * (x+y));
//formula slip = (1/3);
//formula slip = 0;

module strategy
	pick : [0..4] init 0;
	mem : [0..1] init 0;

	[p] pick = 0 & mem = 0 & xobs = 0 & yobs = 0 & end = false -> (mem'=M_0_0_0_0) & (pick'=P_0_0_0_0);
	[p] pick = 0 & mem = 1 & xobs = 0 & yobs = 0 & end = false -> (mem'=M_1_0_0_0) & (pick'=P_1_0_0_0);

    [p] pick = 0 & mem = 0 & xobs = 1 & yobs = 0 & end = false -> (mem'=M_0_1_0_0) & (pick'=P_0_1_0_0);
	[p] pick = 0 & mem = 1 & xobs = 1 & yobs = 0 & end = false -> (mem'=M_1_1_0_0) & (pick'=P_1_1_0_0);


    [p] pick = 0 & mem = 0 & xobs = 0 & yobs = 1 & end = false -> (mem'=M_0_0_1_0) & (pick'=P_0_0_1_0);
	[p] pick = 0 & mem = 1 & xobs = 0 & yobs = 1 & end = false -> (mem'=M_1_0_1_0) & (pick'=P_1_0_1_0);

    [p] pick = 0 & mem = 0 & xobs = 1 & yobs = 1 & end = false -> (mem'=M_0_1_1_0) & (pick'=P_0_1_1_0);
	[p] pick = 0 & mem = 1 & xobs = 1 & yobs = 1 & end = false -> (mem'=M_1_1_1_0) & (pick'=P_1_1_1_0);

	[east] pick=1 -> (pick'=0);
	[west] pick=2 -> (pick'=0);
    [north] pick=3 -> (pick'=0);
	[south] pick=4 -> (pick'=0);
endmodule

module main
x : [1..N];
y : [1..M];
[east] true -> slip: true + (1-slip):(x'=min(x+1,N));
[west] true -> slip: true + (1-slip): (x'=max(x-1,1));
[north] true -> slip: true + (1-slip):(y'=min(y+1, M));
[south] true -> slip: true + (1-slip):(y'=max(y-1, 1));
endmodule

label "done" = x=N & y=M;

rewards "steps"
    pick != 0 : 1;
endrewards
